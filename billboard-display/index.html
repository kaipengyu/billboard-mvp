<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Smart Billboard</title>
  <style>
    /* ── Reset & base ────────────────────────────────────── */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg:        #1a0a2e;
      --surface:   #2a1050;
      --accent:    #7c3aed;
      --accent-hi: #a855f7;
      --text:      #f5f0ff;
      --muted:     #9d8fc0;
      --error:     #f87171;
      --dot-ok:    #4ade80;
      --dot-wait:  #facc15;
      --dot-err:   #f87171;
    }

    html, body {
      height: 100%;
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    /* ── Layout ──────────────────────────────────────────── */
    .billboard {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 32px 48px 24px;
    }

    /* ── Top bar ─────────────────────────────────────────── */
    .top-bar {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      min-height: 28px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--dot-wait);
      flex-shrink: 0;
    }
    .status-dot.ok   { background: var(--dot-ok); }
    .status-dot.err  { background: var(--dot-err); }

    .countdown {
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0.04em;
    }

    /* ── Message stage ───────────────────────────────────── */
    .stage {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px 0;
    }

    .message-box {
      max-width: 860px;
      text-align: center;
    }

    .message-text {
      font-size: clamp(1.6rem, 3.5vw, 2.8rem);
      font-weight: 600;
      line-height: 1.45;
      letter-spacing: -0.01em;
      color: var(--text);
      transition: opacity 0.4s ease;
    }

    .message-text.fading { opacity: 0; }

    /* Loading animation */
    .loading-wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 18px;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid var(--surface);
      border-top-color: var(--accent-hi);
      border-radius: 50%;
      animation: spin 0.9s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .loading-label {
      font-size: 0.9rem;
      color: var(--muted);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    /* Error state */
    .error-text {
      font-size: 1rem;
      color: var(--error);
      line-height: 1.6;
    }

    /* ── Footer ──────────────────────────────────────────── */
    .footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-top: 16px;
      border-top: 1px solid rgba(124, 58, 237, 0.3);
    }

    .footer-meta {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.6;
    }

    .footer-meta span { display: block; }

    .footer-brand {
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 0.08em;
      color: var(--accent-hi);
      text-transform: uppercase;
    }

    /* ── Subtle gradient pulse in background ─────────────── */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at 50% 40%, rgba(124,58,237,0.18) 0%, transparent 70%);
      pointer-events: none;
      z-index: 0;
    }

    .billboard { position: relative; z-index: 1; }
  </style>
</head>
<body>

<div class="billboard">

  <!-- Top status bar -->
  <div class="top-bar">
    <div class="status-dot" id="statusDot"></div>
    <span class="countdown" id="countdown"></span>
  </div>

  <!-- Message stage -->
  <div class="stage">
    <div class="message-box">
      <!-- Initial loading state -->
      <div class="loading-wrap" id="loadingEl">
        <div class="spinner"></div>
        <span class="loading-label">Locating you&hellip;</span>
      </div>
      <!-- Message -->
      <p class="message-text" id="messageEl" style="display:none;"></p>
      <!-- Error -->
      <p class="error-text" id="errorEl" style="display:none;"></p>
    </div>
  </div>

  <!-- Footer -->
  <div class="footer">
    <div class="footer-meta">
      <span id="locationLabel">Location: detecting&hellip;</span>
      <span id="updatedLabel">Last updated: &mdash;</span>
    </div>
    <div class="footer-brand">ICF Smart Billboard</div>
  </div>

</div>

<script>
  // ── Configuration ────────────────────────────────────────
  const FEED_URL     = 'https://billboard-mvp.vercel.app/feed';
  const INTERVAL_MS  = 60_000; // refresh every 1 minute
  const FETCH_MS     = 20_000; // max 20 s per HTTP request
  const GEO_TIMEOUT  = 10_000; // max 10 s for geolocation
  const GEO_MAX_AGE  = 55_000; // reuse cached position up to 55 s old

  // ── DOM refs ─────────────────────────────────────────────
  const loadingEl   = document.getElementById('loadingEl');
  const messageEl   = document.getElementById('messageEl');
  const errorEl     = document.getElementById('errorEl');
  const countdownEl = document.getElementById('countdown');
  const statusDot   = document.getElementById('statusDot');
  const locationLbl = document.getElementById('locationLabel');
  const updatedLbl  = document.getElementById('updatedLabel');

  // ── State ────────────────────────────────────────────────
  let tickInterval = null;
  let secondsLeft  = 0;
  let firstLoad    = true;
  let lastCoords   = null; // { latitude, longitude, name }

  // ── UI helpers ───────────────────────────────────────────

  function setDot(state) { // 'loading' | 'ok' | 'error'
    statusDot.className = 'status-dot ' + (state === 'loading' ? '' : state);
  }

  function setLoadingLabel(text) {
    loadingEl.querySelector('.loading-label').textContent = text;
  }

  function showLoading(label) {
    loadingEl.style.display = 'flex';
    setLoadingLabel(label || 'Loading…');
    messageEl.style.display = 'none';
    errorEl.style.display   = 'none';
  }

  function showMessage(text) {
    if (!firstLoad && messageEl.style.display !== 'none') {
      messageEl.classList.add('fading');
      setTimeout(() => {
        messageEl.textContent = text;
        messageEl.classList.remove('fading');
      }, 400);
    } else {
      messageEl.textContent = text;
    }
    loadingEl.style.display = 'none';
    errorEl.style.display   = 'none';
    messageEl.style.display = 'block';
    firstLoad = false;
  }

  function showError(text) {
    loadingEl.style.display = 'none';
    messageEl.style.display = 'none';
    errorEl.textContent     = text;
    errorEl.style.display   = 'block';
    firstLoad = false;
  }

  function formatTime(d) {
    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  }

  function startCountdown() {
    secondsLeft = Math.round(INTERVAL_MS / 1000);
    clearInterval(tickInterval);
    tickInterval = setInterval(() => {
      secondsLeft = Math.max(0, secondsLeft - 1);
      countdownEl.textContent = secondsLeft > 0
        ? 'Next refresh in ' + secondsLeft + 's'
        : 'Refreshing…';
    }, 1000);
    countdownEl.textContent = 'Next refresh in ' + secondsLeft + 's';
  }

  // ── Fetch with hard timeout ───────────────────────────────

  function timedFetch(url, options, ms) {
    const ctrl = new AbortController();
    const timer = setTimeout(() => ctrl.abort(), ms);
    return fetch(url, { ...options, signal: ctrl.signal })
      .finally(() => clearTimeout(timer));
  }

  // ── Geolocation ───────────────────────────────────────────

  function getPosition() {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error('Geolocation not supported.'));
        return;
      }
      navigator.geolocation.getCurrentPosition(resolve, reject, {
        enableHighAccuracy: false,
        timeout:    GEO_TIMEOUT,
        maximumAge: GEO_MAX_AGE,
      });
    });
  }

  // ── RSS parse ─────────────────────────────────────────────

  function parseRSS(xml) {
    const doc = new DOMParser().parseFromString(xml, 'application/xml');
    if (doc.querySelector('parsererror')) throw new Error('Invalid RSS from server.');
    const desc = doc.querySelector('item > description');
    if (!desc) throw new Error('No message item in feed.');
    return desc.textContent.trim();
  }

  // ── Feed fetch ────────────────────────────────────────────
  // Tries direct fetch first (works once CORS headers are deployed to Vercel).
  // Falls back to a CORS proxy for static/local file serving in the meantime.

  async function fetchFeed(lat, lng) {
    const url = `${FEED_URL}?lat=${lat}&lng=${lng}`;

    // 1. Direct fetch
    try {
      const res = await timedFetch(url, { cache: 'no-store' }, FETCH_MS);
      if (res.ok) return parseRSS(await res.text());
    } catch (_) { /* CORS blocked — try proxy */ }

    // 2. CORS proxy fallback
    const proxy = 'https://corsproxy.io/?url=' + encodeURIComponent(url);
    const res = await timedFetch(proxy, { cache: 'no-store' }, FETCH_MS);
    if (!res.ok) throw new Error(`Server returned ${res.status}`);
    return parseRSS(await res.text());
  }

  // ── Reverse geocode for footer label ─────────────────────

  async function reverseGeocode(lat, lng) {
    try {
      const res = await timedFetch(
        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=10`,
        { headers: { 'User-Agent': 'smart-billboard-display/1.0' } },
        8000
      );
      if (!res.ok) return null;
      const { address: a = {} } = await res.json();
      const city = a.city || a.town || a.village || a.county || '';
      const st   = a.state || '';
      return city && st ? `${city}, ${st}` : (city || st || null);
    } catch {
      return null;
    }
  }

  // ── Main refresh cycle ───────────────────────────────────

  async function refresh() {
    setDot('loading');

    // ── Step 1: Geolocation ──────────────────────────────
    showLoading('Detecting location…');
    let coords;

    try {
      const pos = await getPosition();
      coords = { latitude: pos.coords.latitude, longitude: pos.coords.longitude };

      // Update footer immediately with raw coords, then replace with city name async
      locationLbl.textContent =
        `Location: ${coords.latitude.toFixed(4)}, ${coords.longitude.toFixed(4)}`;

      if (!lastCoords || !lastCoords.name) {
        reverseGeocode(coords.latitude, coords.longitude).then(name => {
          if (name) locationLbl.textContent = 'Location: ' + name;
        });
      }

      lastCoords = { ...coords, name: lastCoords ? lastCoords.name : null };

    } catch (geoErr) {
      if (lastCoords) {
        // Reuse prior coords silently on subsequent cycles
        coords = lastCoords;
        locationLbl.textContent = 'Location: ' + (lastCoords.name ||
          `${lastCoords.latitude.toFixed(4)}, ${lastCoords.longitude.toFixed(4)}`);
      } else {
        setDot('error');
        const denied = geoErr.code === 1;
        showError(denied
          ? 'Location access denied. Please allow location permission and reload.'
          : 'Could not detect location: ' + geoErr.message);
        startCountdown();
        return;
      }
    }

    // ── Step 2: Fetch message from feed ─────────────────
    showLoading('Loading message…');

    try {
      const message = await fetchFeed(coords.latitude, coords.longitude);
      showMessage(message);
      setDot('ok');
      updatedLbl.textContent = 'Last updated: ' + formatTime(new Date());
    } catch (err) {
      setDot('error');
      // If we already have a message on screen, keep showing it with an error note
      if (!firstLoad) {
        showMessage(messageEl.textContent); // re-show last good message
        updatedLbl.textContent = 'Update failed at ' + formatTime(new Date()) + ' — retrying…';
        setDot('error');
      } else {
        showError('Could not load message: ' + err.message +
          '\n\nMake sure the page is served over HTTPS or that the server has CORS headers enabled.');
      }
    }

    startCountdown();
  }

  // ── Boot ─────────────────────────────────────────────────
  refresh();
  setInterval(refresh, INTERVAL_MS);
</script>

</body>
</html>
